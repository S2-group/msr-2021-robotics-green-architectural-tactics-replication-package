[
{"title": "Announcing the nmea_msgs Package for ROS2", "thread_contents": ["Thanks to the work of ", ", I\u2019m pleased to announce that ", " has been packaged for ROS 2 Crystal and Dashing! ", " will be following soon. (There\u2019s already a ", " branch ", ", but I haven\u2019t finished cleaning it up and blooming it.)", "Powered by ", ", best viewed with JavaScript enabled"], "url": "https://discourse.ros.org/t/announcing-the-nmea-msgs-package-for-ros2/9233"},
{"title": "Replacing novatel_span_driver with novatel_gps_driver", "thread_contents": ["The ", " appears to have fallen out of favor in the community in favor of ", " which is currently maintained by Southwest Research Institute (", "). Development of their driver is more active, it has more features, is more stable, and is easier to change/maintain. What is the feeling among the group about dropping support for the ", " and suggesting to SwRI that we move the repo under the ", " group while keeping them as a maintainer?", "Powered by ", ", best viewed with JavaScript enabled"], "url": "https://discourse.ros.org/t/replacing-novatel-span-driver-with-novatel-gps-driver/9749"},
{"title": "Contributing Apex.AI's ROS 2 Velodyne driver", "thread_contents": ["Hi,", "we at Apex.AI have contributed our ROS2-based ", " to the ", "However, we\u2019d like to contribute this driver to the ros-drivers initiative instead, since we believe that other people may benefit from it. Compared with the existing Velodyne driver, Autoware.Auto\u2019s is lacking support for more models (it only supports VLP16), however the one we developed was done with real time constraints in mind (static memory allocation, deterministic lifecycle, etc.). Moreover, it contains an extensive test suite and has been audited with ", "\u2019s tools to improve its performance.", "I wonder if there could be a way to merge the two efforts or contribute our improvements, we\u2019re happy to maintain the Velodyne driver.", "Thanks.", "Hi Esteve!", "I\u2019m not the maintainer of ", " (that would be ", ") , but I did do the ROS 2 port there (on the ", " branch).  I think it would be awesome to combine the efforts so we don\u2019t have too much duplication.", "That being said, I think it is going to be hard to do without a significant rewrite of one of them (maybe both of them).", "Personally, I\u2019d try to approach this in an iterative fashion where pieces of the Autoware driver get slowly fed into the ros-drivers driver as they make sense.  For example, one place that makes sense to combine is the low-level dissection of packets, since that should definitely be common code.  Another thing that would probably make sense in the upstream velodyne repository is some of the tests.", "However, I don\u2019t know the Autoware version of the code, so I can\u2019t say how far this approach will take us.  Thoughts?", "Actually, ", " is a member of the Autoware project as well and he advised me to chime in here so we all could discuss this in the open ", "We had a few discussions and I agree with him that for a significant number of people, having support for as many models as possible is more important than the real time stuff or the tests.", "So I wonder if by adding support for the rest of models in the Autoware.Auto driver would be easier than breaking it into smaller pieces and adding it to the existing ROS 2 driver in ros-drivers, since it\u2019d require structural changes to accommodate the features we developed.", "So I wonder if by adding support for the rest of models in the Autoware.Auto driver would be easier than breaking it into smaller pieces and adding it to the existing ROS 2 driver in ros-drivers, since it\u2019d require structural changes to accommodate the features we developed.", "There are two major reasons not to use the Autoware driver at the moment:", "If we can solve both of those issues, then bringing support for additional devices into the Autoware driver is fine by me.  Unfortunately, I only have a VLP-16 to test with, so I can\u2019t really help with testing other devices at present.", "It only supports the VLP-16", "Yeah, that\u2019s one of the concerns I raised and I woudn\u2019t pursue merging it until more models are supported.", "It is dependent on a bunch of the Autoware infrastructure (that is, you can\u2019t easily use it or even compile it without bringing in Autoware)", "The Velodyne driver in Autoware only depends on ", " and ", ", the former can be just integrated into the driver, the latter is a consequence of how we developed the driver, where we separated concerns into smaller packages (e.g. reading from a UDP source, translating packets into sensor_msgs messages, etc.) Besides that, there\u2019s no Autoware-specific code, the driver is largely separate from the rest of the Autoware code base.", "The Velodyne driver in Autoware only depends on ", " and ", " , the former can be just integrated into the driver, the latter is a consequence of how we developed the driver, where we separated concerns into smaller packages (e.g. reading from a UDP source, translating packets into sensor_msgs messages, etc.) Besides that, there\u2019s no Autoware-specific code, the driver is largely separate from the rest of the Autoware code base.", "Sure.  What I\u2019m trying to get at is that users who are ", " Autoware (or automotive at all) want to just be able to pull a small source repository, build it, and launch it.  While I agree that the Autoware Velodyne driver doesn\u2019t have a heavy dependency on Autoware, it does have ", " dependencies (", " and the ", " and ", " are all examples).", "I think that the Velodyne driver should be totally independent from Autoware.  It should have its own source repository and not be dependent on any Autoware-specific bits.  How many packages and how it is split up is less important to me.  But that kind of gets us back to my original proposal to put it in ", " ", "I think that the Velodyne driver should be totally independent from Autoware. It should have its own source repository and not be dependent on any Autoware-specific bits. How many packages and how it is split up is less important to me. But that kind of gets us back to my original proposal to put it in ", " ", "Sorry, what I meant is that we also want to contribute all those other packages as well, so that the driver does not to pull anything from the Autoware.Auto repository and stays completely independent. Also the the way we separated each part of the driver may benefit other drivers. For example, the udp_driver package can be used to write drivers for any other sensor that spits out UDP packets. Additionally, it\u2019s fairly straightforward to port the udp_driver to TCP or serial ports.", "Sorry, what I meant is that we also want to contribute all those other packages as well, so that the driver does not to pull anything from the Autoware.Auto repository and stays completely independent. Also the the way we separated each part of the driver may benefit other drivers. For example, the udp_driver package can be used to write drivers for any other sensor that spits out UDP packets. Additionally, it\u2019s fairly straightforward to port the udp_driver to TCP or serial ports.", "Perfect!  That works for me.  There\u2019s a minor issue in that we\u2019ll probably have a time period where both the old velodyne repository and the new one you are working on are both active, and it may be hard for users to figure out which one to use.  But we can fix that with documentation.", "Thanks for the discussion.", "Perfect! That works for me.", "Awesome ", " I\u2019m going to spin off the driver into its own GitHub repository to ensure that it can be made completely independent from Autoware and then we can start working on integrating it into ros-drivers.", "This sounds like an excellent plan, gentlemen! I also believe that a seperate, modular TCP/UDP stack is the best way to go and the principals used to develop the AutowareAuto driver are the right approach. ", " - would it be possible for you to split the TCP/UDP layer into its own repository and then have another for the Velodyne driver that relies on it? I\u2019d be happy to create the network driver repo under ros-drivers.", "would it be possible for you to split the TCP/UDP layer into its own repository and then have another for the Velodyne driver that relies on it?", "Sure thing. I\u2019m currently setting up ", " and ", ", but once I get the CI working, I\u2019ll merge the latter and will create a separate repository for the udp_driver package.", "I\u2019ve put all the packages in a separate repository in ", ", but for some reason CI fails with an error in ament_cppcheck. I filed an ticket in ", " but I\u2019m unsure where the issue is.", "I\u2019d be happy to create the network driver repo under ros-drivers.", "Let me know when you\u2019ve created the repository, and I\u2019ll submit a pull request to add the ", " package.", " / ", " / ", " / ", " / ", "  - You guys are owners of the ", " organization on GH. Can one of you create a new repo called something like ", " or ", " or ", " and we will import the ", " as the first package in the stack? That or promote me to an ", " and I can set it up. We\u2019ll need a ", " repo as well under ", " eventually.", "I\u2019ve created ", " and ", " and have given access to the Velodyne Maintainers team to both.", "PS We might want to review the naming but I went with the most descriptive one I saw on the list above.", "Thanks, ", ". However, I think these will only be targeting ROS2. Can you create ", " or does only ", " have access for that organization?", "I have access, but in general as we\u2019re moving forward we\u2019re decreasing the differentiation between ROS 1 and ROS 2 hosting.", "We started with ROS 2 in a separate organizations to make sure not to disrupt ongoing development in ROS 1 and to avoid miscommunications about people grabbing the wrong version of things while they were early in the development cycle.", "However now that we\u2019re mature and working on transitioning things from ROS 1 to ROS 2 many are going to be maintained in development branches on the original upstream repositories. Duplicating every repository and every team and maintaining all of that in parallel on multiple github organizations doesn\u2019t make sense in the bigger picture. In general we\u2019re working to converge development back into the main repository even for things that we forked for ROS 2 since most of the codebase will be overlapping and bug fixes and issue tracking can apply to both versions as well as it\u2019s common for maintainership to be shared.", "Thanks for the clarification, ", ".", " Could you add me to the Velodyne team as well? I\u2019d like to upload the udp_driver from the Autoware.Auto Velodyne driver. Thanks ", "Sure, invitation sent.", "Powered by ", ", best viewed with JavaScript enabled"], "thread_details": ["It only supports the VLP-16", "It is dependent on a bunch of the Autoware infrastructure (that is, you can\u2019t easily use it or even compile it without bringing in Autoware)"], "url": "https://discourse.ros.org/t/contributing-apex-ais-ros-2-velodyne-driver/10223"},
{"title": "Add @clalancette to phidgets-maintainers", "thread_contents": ["Could somebody with admin access to the ros-drivers Github group please add ", " to the ", " team? Also see:", "Thanks!", "Powered by ", ", best viewed with JavaScript enabled"], "url": "https://discourse.ros.org/t/add-clalancette-to-phidgets-maintainers/10545"},
{"title": "New UR driver for ROS coming soon", "thread_contents": ["Hi all, as we received questions around some corners whether the new UR driver developed as part of the ROSin project (", ") is abandoned.", "I can assure you, that it has not died and in fact will be released soon, hopefully. Currently, there are only one or two minor issues being resolved and there\u2019s still some documentation to write before we will make the code available to the public.", "We received mainly positive feedback from our closed beta group, so we are eagerly looking forward to open the project to a wider audience soon.", "Please understand, that we don\u2019t want to give a fixed deadline to not disappoint anybody. However, we do have an internal deadline not too far away, that we are confident to meet.", "There is a lot going on around the driver development. Other improvements going on in the universal_robots repository are closely related to this topic. For example, the following issue is related to a urdf description helping to get a calibrated robot representation. Contribution there is very welcome ", ", especially if you are a bit more familiar with gazebo than I am.", "To give you an estimate on what to expect from the new driver, we prepared a small feature comparison and roadmap listing the new driver\u2019s features. If that list is to some extent wrong, please let me know. Any errors are not intentional.", " Depending on the mode the driver is running the panel won\u2019t react or using the panel", "\nwill stop the program without notifying the ROS user.", " In velocity mode this is implicitly given.", " There is no specific plan to do this inside of the first driver development. However,", "\nit is structured in a way so that a ROS2 driver should be developed as easy as possible by keeping", "\nas much as possible in a ros-independent library.", "trajectory extrapolation on robot on missing packages", "could you explain quickly what that means? Generally I\u2019m wondering if that implies that I could use the new driver in a ", " like position controlled way without the need for a real-time kernel?", "\u2026that implies that I could use the new driver in a ros_control like position controlled way without the need for a real-time kernel?", "Not exactly. While the real-time kernel requirements are in fact important to assure that the control cycle on the ROS machine runs in the required time windows, extrapolation on the controller is a separate layer on top meaning that the robot will continue its current movement using a constant velocity model.", "Basically, this is another layer to make sure that the robot is not showing any \u201chickup\u201d motions due to missing packages. Except from a non-real-time kernel those could be generated by delays in the TCP stack or network communication.", "Whether a real-time kernel is a really hard requirement for your usecase depends on a couple of factors:", "With this all being said, let me state, that we highly recommend using a real-time kernel. During initial tests we checked that without a real-time kernel a significant amount of cycles took more than twice the time intended.", "Powered by ", ", best viewed with JavaScript enabled"], "thread_details": ["With a CB3 robot with a control rate of 125 Hz you could get away without using a real-time kernel", "If your control-pc is not running anything else than the driver chances are lower that the controller gets interrupted by other processes meaning that you could also get away with a non-real-time kernel", "If your only concerns are smooth motions, the controller extrapolation could be enough. However, the robot will not be following the desired path necessarily, as it is doing linear extrapolation only."], "url": "https://discourse.ros.org/t/new-ur-driver-for-ros-coming-soon/10652"},
{"title": "Release Repositories for ROS2", "thread_contents": ["Reproducing message from ", " here for visibility:", "Thanks to some community efforts, nmea_msgs now has a ros2 branch that builds in Crystal Clemis. nmea_navsat_driver will be following shortly. As far as I can tell, these are the first ROS-drivers packages to be ported to ROS2.", "Now I\u2019m looking into blooming both packages for ROS2. The ", " recommends creating a new -release repo when porting ROS1 packages to ROS2. How do we want to go about this? Should we create a new Github group for ros2-drivers-gbp, or should we make new -ros2-release repositories under ", "?", "If we want to keep using the existing Github group for releases, I\u2019ll need some help from one of the admins (Sam, Jack, Piyush, ", ", or William) to make release repos for the nmea packages.", "Cheers,", "Ed Venator", "Maintainer, ", " and ", "I would not recommend creating a new organization. That will incur significant extra coordination overhead for coordinating the same group. The release repos can get large quickly so I\u2019d suggest just a parallel release repository. At some point it is useful to rotate to a new release repository of the repository gets too large to save time checking it out.", "I agree with ", ", which means we need some help from the GitHub group owners.", " ", " can either of you help me by making ROS 2 release repos for nmea_msgs and nmea_navsat_driver?", "Done:", "Contribute to ros2-gbp/nmea_msgs-release development by creating an account on GitHub.", "Contribute to ros2-gbp/nmea_navsat_driver-release development by creating an account on GitHub.", " I invited you to a team that has access.", " - Can  you do the same for ", "? We will have a working release very soon.", "Done:", "Contribute to ros2-gbp/velodyne-release development by creating an account on GitHub.", "I added you and Mike Purvis, since he was in the team for the ROS 1 release repository too (", ").", "I would like to release ", " into ROS2 (in case wrapping/packaging non-ROS cmake packages with a package.xml file and applying necessary patches is still best-practice in ROS2).", "\nThe ROS1 release repository is located in ", ".", "\nShould we proceed for ROS2 similarly and add it to ros2-gb? Can someone with permissions create the repository, i.e. ", " or ", "? Many thanks!", " I created ", " and invited you to a team on that organization so you can have access. I may need to tweak your permissions once you accept. Feel free to poke me via email or here you\u2019ve gotten access.", "thank you ", "! I got access to the team ", "Powered by ", ", best viewed with JavaScript enabled"], "url": "https://discourse.ros.org/t/release-repositories-for-ros2/8912"},
{"title": "Announcement: Universal Robots launches ROS driver", "thread_contents": ["Hi ROS enthusiasts,", "We are delighted to announce, that we have ", "!", "Robot Operating System (ROS) is widely used within the industrial research and educational field, for exploring robot technology, or for developing advanced systems. Since the beginning of UR, clever minds in the research field have developed 3rd party drivers, enabling the ROS community to communicate with UR robots for various purposes. Impressively, more than 200 different forks of UR-compatible drivers filled up the ROS landscape. However UR has never supported nor developed any of these drivers. Until now!", "With so many community developed ROS-drivers in the landscape, it became difficult to find out which fork had the latest features, supported the right version of your UR software, or utilized the UR functionality in the best way. To mitigate these issues, and ensure that a solid driver utilizing all the best feats of the UR was available, we partnered with the German research institute ", " to cooperate on the development of an ROS driver that is backed by UR to ensure its stability and robustness.", "The new ROS driver provides a number of key benefits:", "The ROS driver is provided through UR\u2019s GitHub account, which allows for open collaboration within the ROS community.", "\nThere are two modes of operation for the driver:", "Go check out the new ROS driver today;", "\n", "Driver enabling ROS operation of UR robots. Contribute to UniversalRobots/Universal_Robots_ROS_Driver development by creating an account on GitHub.", "\n", "Furthermore, you can check out the two accompanying URCap implementations;", "\n", "Example implementation of how to use ROS driver on-demand in a URCap. - UniversalRobots/Universal_Robots_ExternalControl_URCap", "\n", "\n", "Utility to forward the UR Tool Communication Interface (RS-485) to a ROS remote PC. - UniversalRobots/Universal_Robots_ToolComm_Forwarder_URCap", "\n", " wrote up a good summary comparing the ", " to the new driver:", "\n", "\n", "If you encounter issues or bugs using the ROS driver, please use the Issue-reporting system for the respective GitHub repository.", "\nShould you have questions to using the ROS driver, or general support requests, please use the ", " in the ", ".", "Happy development,", "Your Universal Robots team   ", "Great achievement, lets hope that other manufacturers follow!", "The driver includes the specific robot\u2019s factory calibration data for improved accuracy.", "Does that include a way to calculate ik for the calibrated robot in an efficient way? We once had to resort to seeding a numerical ik-solver (trak-ik) with the solution from ikfast for the ideal robot as build quality was so bad.", "Does that include a way to calculate ik for the calibrated robot in an efficient way? We once had to resort to seeding a numerical ik-solver (trak-ik) with the solution from ikfast for the ideal robot as build quality was so bad.", "The xacro itself is updated (via a ", " file), so anything that uses the urdf to initialise the IK solver benefits.", "Somewhat off-topic, but:", "Great achievement, lets hope that other manufacturers follow!", "Congratulations to FZI & UR of course for this release, and we\u2019ve supported them gladly, but there are already quite a few (industrial) robot manufacturers that have released publicly supported ROS drivers. I won\u2019t name them here though, as this it not the place, but it is only fair to acknowledge their support as well.", "Ok, but nothing ur specific that could work in cases where ", " fails?", "nothing ur specific", "I\u2019m not sure what you mean by this, but there are currently no updates to ", " to take the calibration into account, if that is what you were asking.", "That would not be impossible though, I believe. But out of the scope for the FZI & UR collaboration at this point. Community contributions are most likely welcomed.", "I\u2019m not sure what you mean by this, but there are currently no updates to ", " to take the calibration into account, if that is what you were asking.", "That would not be impossible though, I believe.", "Well I assume they have something akin to ", " implemented on the controller which works event though the calibration might (?) break geometric assumptions made when deriving ", "? But that is most likely considered IP I guess.", "This might be a question best asked on the issue tracker.", "I can\u2019t really understand what you\u2019re writing here, but that\u2019s probably on me.", "To be clear: all control is still joint space based. There is no Cartesian interface (yet). It\u2019s a standard ", " based ", " which exposes the 6 revolute joints of the robot over RTDE in position mode. There is an experimental PR adding a velocity interface and the secondary and primary interfaces are also still used for some things (but not motion).", "That is at a very high level. As always there are many more details influencing this, but for those I\u2019d suggest posting either on the tracker or the UR support forum (which is behind a login).", "What ", " wrote applies to FK based on joint states: that will now take per-robot calibration into account, leading to orders of magnitude more precise results. On-controller compensation for things like gravity and link deflection is not part of that.", "However, as MoveIt (fi) for planning Cartesian goals is also using the same IK solver, it should affect control of the robot\u2019s EEF and positioning of that as well (as more accurate IK -> more accurate joint space goals).", "But I\u2019ll leave the rest to ", ", UR and FZI ", "Thank you  ", " for summing this up very well. Our focus was indeed on joint-based control and correct forward kinematics.", "Currently, we don\u2019t plan further developing ", " though.", "Powered by ", ", best viewed with JavaScript enabled"], "thread_details": ["\n", "\nFor ROS users, the driver provides an easy and plug\u2019n\u2019play use of UR robots.", "\n", "\nThe ROS driver utilizes all the key features of the UR robot to achieve state of the art performance.", "\nIt provides an industrial grade interface to the best extent allowed by current ROS practice.", "\nThe driver includes the specific robot\u2019s factory calibration data for improved accuracy.", "\n", "\nThe driver is built on stable and versioned API\u2019s, and is integrated into UR\u2019s continuous testing engine for assured quality.", "\n", "\nThe driver will remain open-source and rely on future community contributions.", "\n", "\n", ": easy programming research, embedding in OEM systems.", "\nIn this mode, the driver works like classic ROS drivers, assuming full remote control of the robot without interaction on the teach pendant.", "\n", "\n", ": Developers of vision systems, force/torque control, picking algorithms or similar products, which integrate with ROS.", "\nIn this mode, a sample URCap enables ROS control only where it is needed in the UR program. In this way it enables easier integration with ROS compatible devices into UR applications. It further enables commercialization of cutting edge technologies based on ROS."], "url": "https://discourse.ros.org/t/announcement-universal-robots-launches-ros-driver/10952"},
{"title": "ROS Driver Common Interface Standards", "thread_contents": ["Are there standards for ROS drivers that describe common interfaces for various actuators and sensors that are independent of specific manufacturers and hardware? If so, where might those be found? If not, are there plans to create or adopt such standards or models? Debating standards is never fun, but the dream of having interoperable, interchangable driver packages is very compelling.", "I have seen the ", " and it seems like a great idea. Is this being actively used by the community and maintained?", " seems even more ambitious and general, but it appears that they do not yet have models for many hardware components.", "Is there any agreement about using one of these or some other guidelines when writing driver packages so they are as interchangeable and interoperable as possible?", "For example, I use lots of different motor drivers and controllers, each with its own API. I would like to write a ROS driver for each one and use the same interface for all of them. A general enough interface might work with stepper motors, motors with encoders, rotary actuators, linear actuators, etc, but even if the interface just removed the differences between manufacturers for the same type of motor that would be very useful. Has anyone worked out a common interface for such motors? Or does every ROS motor driver package have its own slightly different interface? What about other actuators and sensors? Thanks!", "For sensors, I\u2019d say by in large the defacto standard (and some of these messages have formal REPs on them) is the sensor_msgs format: ", ". For any message in here, I expect a driver for a hardware provider to conform to these are far as they are possible (which is 95% of cases).", "For sensors, I\u2019d say by in large the defacto standard (and some of these messages have formal REPs on them) is the sensor_msgs format: ", ". For any message in here, I expect a driver for a hardware provider to conform to these are far as they are possible (which is 95% of cases).", "We saw in the past several manufacturers \u201ccustomize\u201d those message to meet their hardware. This in some cases broke interoperability and it\u2019s what led to the creation of HRIM listed above.  HRIM follows a MDE approach and while it builds on top of the standard ROS messages (including sensor_msgs),   validates inteoperability through the use of models.", "For example, I use lots of different motor drivers and controllers, each with its own API. I would like to write a ROS driver for each one and use the same interface for all of them. A general enough interface might work with stepper motors, motors with encoders, rotary actuators, linear actuators, etc, but even if the interface just removed the differences between manufacturers for the same type of motor that would be very useful. Has anyone worked out a common interface for such motors? Or does every ROS motor driver package have its own slightly different interface? What about other actuators and sensors?", "A similr use case motivated the creation of HRIM. IMHO, you definitely will benefit from using a model-driven engineering approach. Unfortunately, AFAIK, HRIM project is not supported by any entity/individual any further but you\u2019re welcome to jump in and start maintaining it.", "RobMosys is indeed ambitious and will turn interesting if executed appropriately. There\u2019s a project that connects both RobMosys and HRIM you may want to check ", " and reach out for more information.", "Indeed, one of the largest advantages of ROS is the standardization of manufacturer-independent interfaces (standard messages) that it provides. For example:", "Some more things are standardized in the form of ", ".", "My 2cents here, regarding the model part, I will highlight my colleague ", " work :  ", ".", "The goal here is not to define a common standard, but to provide a nice tool to help/support modeling of ROS code. It uses static analyzer (", ") to automatically generate the model of the code but also can be used to manually generate the model of your system / code.", "Personally I use this tool to check that a driver follow some specification that I arbitrary established for another project.", " I think you have a really good point about figuring out common models that build on top of the standard ROS messages. If we want to be able to swap one driver package for another, it is important to both be using the same messages and using them in the same way.", "For example, if you look at these ", " it seems that most use standard ROS messages, but it does not appear that any of these packages use them in the exactly the same way so that one package cannot be swapped out for another without changes to the packages that interface with them.", "ROS-MDD does look very promising, thank you for sharing that. Combining HRIM and RobMoSys does seem like a great idea if done well. I am curious about the best way to write ROS drivers until that work gets completed.", "In the specific case of motor drivers, maybe the best approach is to use control_msgs for driver input and sensor_msgs for driver output and custom messages for anything else that does not quite fit until something better comes along.", "From what I see, we have the \u201cminimal\u201d msg-based approach on the one end of the spectrum, and we have various model-based approaches on the other end of the spectrum.", "On the one hand it appears obvious that \u201cmessages with comments\u201d is an ad-hoc format and that something more formal would be great. On the other hand, I\u2019m not seeing much adoption of model-based approaches.", "To see why, it might be useful to look at what people are doing now, to cope with this. FWIW, the use-case that ", " describes, where you have lots of different actuators and controllers \u2013 that\u2019s not a common use-case in industry or research amongst ROS users. Most people I know try to standardize very quickly on a very limited set of controllers and platforms.", "What\u2019s more, most people don\u2019t see a problem with this. They don\u2019t standardize on motors to avoid the differences in ", ". They do it, because it makes most sense for integration, performance and cost to do that.", "This doesn\u2019t mean the problem is irrelevant, just that most people are coping right now, and that any solution to the problem better be really use to use, very well supported with tools and implementations, and vendor-agnostic. Despite some promising starts, I would argue that both HRIM and RobMoSys are still quite far from that.", "An interesting example of how this could look is ", ". It\u2019s a very generic set of motor controller interfaces. Also quite widely implemented, though almost never fully.", "Are there \u201cbest practices\u201d for the topic/action types that a motor driver should use?", "What I mean is something analogous to cameras. IMO, the best practices for a camera driver are clearly defined:", "Is there something analogous for motor drivers? All I can think of is that the current motor position should probably be published as a ", " and not encoder ticks or similar. What about the input topics? Should it be a plugin for ", " instead of a standalone node?", "Are there \u201cbest practices\u201d for the topic/action types that a motor driver should use?", "I\u2019m always wondering whether this would standardise the ROS API of the \u201cmotor driver\u201d or of the entities that are connected to those motors (ie: joints).", "For joints we have ", " and ", " to close the loop, but there is no concept of \u201cmotors\u201d there, nor \u201cmotor drivers\u201d.", "There doesn\u2019t necessarily need to be, but it\u2019s important to recognise the difference I believe.", "I\u2019ve thought of this as a transparent bridge vs opaque proxy or facade difference.", "I\u2019m always wondering whether this would standardise the ROS API of the \u201cmotor driver\u201d or of the entities that are connected to those motors (ie: joints).", "Probably both, right?", "I think that message definitions are not enough to define a driver interface. There are also different topic hierarchies that need to be agreed on to formulate a standard driver interface.", "\nAs ", " pointed out, there are accepted best practices for some device types that define a set of expected message types and topics. But these are not enforced and a node interacting with a camera cannot rely on this set of messages and their topic hierarchy.", "Since ROS2, we have a unified API for ROS nodes and I think we should take this one step further and define device interfaces (as e.g. C++ abstract classes) that define all topics and message types a driver needs to provide. Any driver node would then inherit from this interface and implement it accordingly.", "As an example, there could be an abstract C++ class ", " that inherits from ", " and defines methods for publishing and subscribing to the \u201cbest practice\u201d topics and messages. Any ROS2 camera node would inherit from ", " (instead of ", ") and implement the interface.", "\nAny node relying on a camera node could then assume a common interface.", "FWIW, the use-case that ", " describes, where you have lots of different actuators and controllers \u2013 that\u2019s not a common use-case in industry or research amongst ROS users", "True, my use-case is probably not very typical. I build robotics for scientists and each scientist has his or her own preferences for the sensors and actuators they want to use in their experiments. Very similar experimental pieces keep getting redeveloped over and over again because nothing can be shared and reused, wasting lots of development time and collaboration opportunities.", "Instead of trying to convince all of the scientists to use the same sensors and actuators, which is never going to happen, I would love to have a set of really good common interfaces that make the specific choice of sensor or actuator manufacturer irrelevant. Then other experiment packages, like behavior trees or user interfaces or data processing nodes, do not care if they are exchanging messages with a Phidgets motor driver or a Zaber motor driver or whatever.", "Even though other ROS users standardize on their own sensors and actuators and do not care about such flexibility, we could all benefit by being able to share and reuse ROS drivers and easily be able to swap one for another in the bigger ROS ecosystem. Instead of having something like 10 drivers with very similar, but incompatible interfaces.", "I do not want to develop my own common interfaces and then try to convince the world to adopt them, that is as impossible as trying to convince everyone to use the same sensors and actuators. I am hoping that there are some common guidelines or models or something agreed upon by a group of people that would help me know what interfaces I should use with the ROS drivers I need to write.", "There are also different topic hierarchies that need to be agreed on to formulate a standard driver interface.", "I do agree with you.", "I think we should take this one step further and define device interfaces (as e.g. C++ abstract classes)", "I believe that this is strongly required, if we actually think about the application framework. (though, not sure this is exactly in the scope of ROS)", "I believe that this is strongly required, if we actually think about the application framework. (though, not sure this is exactly in the scope of ROS)", "I\u2019m honestly not sure that\u2019s where we want to go with ROS.  In ROS(2), the interface really is the messages, services, and actions; it\u2019s not the C++ API.  This is even more important when you think about alternate client libraries (like the Python, Javascript, Java, etc).  So while defining these classes might be convenient, it doesn\u2019t really scale across the different libraries that people want to use.", "That being said, I agree that standardization at the message level would probably be valuable for more pieces of ROS.  There are already REPs ", " a ", " ", " standardized messages, so I\u2019ll suggest someone who is interested in this topic think about writing a (several?) REP and opening a PR against ", " to start the conversation there.", "the interface really is the messages, services, and actions; it\u2019s not the C++ API.", "I did not meant to enforce a certain C++ API. The abstract C++ class was an example for an interface definition that could be implemented by C++ driver nodes. The same applies to the Java Interface or an abstract class in Python. May languages allow you to define some kind of interface.", "I wanted to emphasise that message, action and service definitions alone do not define the \u201cproper\u201d interface to a node. Many nodes read/write to multiple topics. And especially for the camera the \u201cstandard\u201d / \u201cbest practice interface\u201d is more than just the ", ". Similarly, TCP alone doesn\u2019t allow you to browse the internet - you need to agree on multiple standard interfaces.", "A C++/Python/Java/Rust driver node would need to inherit this interface and implement it. This would ensure that the same topic hierarchy and types are used. In the end, messages are just a hierarchical structure for POD low-level types. You could as well define a huge \u201ccamera\u201d message that incorporates the message types of all topics and publish this on a single topic as the one-and-only interface. On the other hand, you could just send all the POD types on separate topics.", "I wanted to emphasise that message, action and service definitions alone do not define the \u201cproper\u201d interface to a node. Many nodes read/write to multiple topics. And especially for the camera the \u201cstandard\u201d / \u201cbest practice interface\u201d is more than just the ", " . Similarly, TCP alone doesn\u2019t allow you to browse the internet - you need to agree on multiple standard interfaces.", "Indeed the messages alone do not define a full interface. But I agree with Chris that it\u2019s better to focus on language independent definitions of the interfaces. And I agree that looking to the REP process is likely the best approach. There\u2019s one example of adding semantics on top of messages in ", " and a new propsal for IMUs ", " And the TurtleBot\u2019s main interfaces are defined in ", " And there\u2019s also an in process for aerial vehicles ", " but we have many others that are less formally documented in the wiki, like ", "This is following the same sort of process as web interface specifications that you compare to where those are defined as messages and ordering and states required for communications. And specifically are completely language neutral. Then they can be implemented by a c++ webserver or a python web server and the other end doesn\u2019t care what language the other side is implemented in just that the protocol is implemented as per the specification.", "But I agree with Chris that it\u2019s better to focus on language independent definitions of the interfaces.", "There seems to be some confusion about the interface definition using topics and messages as seen from the outside of a node, and the language-specific API that is used internally to implement the behaviour of a node.", "The set of message definitions and their hierarchical structure is inherently language-neutral. All message/action/service definitions in ROS are using a language-independent description format.", "What I am proposing is to define this structure in the same way as messages/etc. are define nowadays in ROS.", "\nFor example, the language-agnostic interface definition for a camera could look like:", "And this interface could be translated into language-specific interfaces like C++ abstract classes, Java Interfaces, etc. in a similar way, as it is already done with messages and services now in ROS.", "A driver node (in whichever language) would inherit from this generated language-specific interface (abstract class, etc.) and implement the behaviour. Of course, if you want to use that same language-agnostic interface in another language, you will have to write a generator in the same way, as you have to write a new generator for messages if you want to use them in Rust/Haskell/Lisp/etc.", "The difference to the web interface is that the web uses a layered model, whereas such a driver interface would define the entire interface at once. However, both are language-neutral.", "\n", "\n", "thanks for your insights,", "what i really care is application portability which should be independent on drivers.", "A driver node (in whichever language) would inherit from this generated language-specific interface (abstract class, etc.) and implement the behaviour.", "so that i was thinking that this could be a way.", "And this interface could be translated into language-specific interfaces like C++ abstract classes, Java Interfaces, etc. in a similar way, as it is already done with messages and services now in ROS.", "A driver node (in whichever language) would inherit from this generated language-specific interface (abstract class, etc.) and implement the behaviour. Of course, if you want to use that same language-agnostic interface in another language, you will have to write a generator in the same way, as you have to write a new generator for messages if you want to use them in Rust/Haskell/Lisp/etc.", "The difference to the web interface is that the web uses a layered model, whereas such a driver interface would define the entire interface at once. However, both are language-neutral.", "While this approach might be useful, it does have the significant drawback of that you end up enforcing on driver implementers not just the external interface (which you do want) but also the implementation design (which you often don\u2019t).", "You don\u2019t want to enforce implementation design as a single-class node because that limits driver implementers from being able to compose multiple nodes to create a driver if that is best for their application. You also restrict the developer from adopting other implementation structures they may need for their application, such as to meet a safety requirement to a sufficient degree of reliability or to handle a distributed control system.", "Another drawback is that it would make client libraries that much more complex to implement and maintain.", "I think that your idea of an interface specification is useful (indeed, the concept is not new and is well-regarded), but for ROS what would be better than forcing everyone to generate their nodes from it would be a verification tool that confirms a node matches the interface it declares to implement. You could put this in the ", " file and have automatic linters and record the results on ", ".", "I agree with Tully that a REP specification of interfaces is the best approach. Then we can build tools on top of that appropriate for different use cases, including a library of base classes for those who want them.", "You don\u2019t want to enforce implementation design as a single-class node because that limits driver implementers from being able to compose multiple nodes to create a driver if that is best for their application. You also restrict the developer from adopting other implementation structures they may need for their application, such as to meet a safety requirement to a sufficient degree of reliability or to handle a distributed control system.", "I agree with this. If you want to enforce such an interface on the implementation side, I don\u2019t see another solution than forcing node creators to implement the interface.", "but for ROS what would be better than forcing everyone to generate their nodes from it would be a verification tool that confirms a node matches the interface it declares to implement.", "Right. This is the de facto standard or \u201cbest practice\u201d interface. But at the moment, there is no verification or check for standard compliance, e.g. like its done for DDS, that would allow someone who wants to build on top of camera drivers etc. to make sure that the camera post-processing node will work with any camera driver that claims to implement these standard/\u201cbest practices\u201d.", "Powered by ", ", best viewed with JavaScript enabled"], "thread_details": ["cameras publish sensor_msgs/Image and sensor_msgs/CameraInfo", "motors publish sensor_msgs/JointState", "robot arms provide the control_msgs/FollowJointTrajectoryAction", "etc.", "It should publish ", " messages.", "It should publish ", " messages that are synchronized with the Image messages and provide a ", " service (both can be accomplished via ", ").", "It should read the calibration from a ", " parameter.", "It should provide a set of compressed images (via ", ")."], "url": "https://discourse.ros.org/t/ros-driver-common-interface-standards/11435"},
{"title": "New Hardware Interface for Ingenia Motor Drives", "thread_contents": ["Hi all !", "In the context of ", " EU Project,  ", " has developed a C++ interface and its corresponding ROS Hardware interface for the ", " motor drives.", "\nThe package allows motor control with the following features:", "Click ", " for a demo video, documentation and GitLab repository links.", "Enjoy motion!", "Beta Robots team", "Powered by ", ", best viewed with JavaScript enabled"], "thread_details": ["Position, velocity, and torque modes", "High control rates", "Status monitoring", "Optional soft-safety layer", "Custom controllers plug-in for advanced applications", "EtherCAT communications interface"], "url": "https://discourse.ros.org/t/new-hardware-interface-for-ingenia-motor-drives/12599"},
{"title": "About the Drivers category", "thread_contents": ["Our group has been operating continuously since the end of 2011. We mainly focus on defining common interfaces and best practices, so various classes of drivers work consistently with other ROS components. Please join us if you are interested and willing to contribute.", "This group previously was available on google groups: ", " and before that on ", " (defunct)", "Powered by ", ", best viewed with JavaScript enabled"], "url": "https://discourse.ros.org/t/about-the-drivers-category/8878"}
]